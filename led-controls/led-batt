#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Time::HiRes qw(sleep);
use List::Util qw(max);

my $pidfile = "/tmp/led-batt-pid";

my @synonymsArr = (
  'off' => [qw(o g 60)],
  'green' => [qw(o G 60)],
  'orange' => [qw(g O 60)],
  'both' => [qw(G O 60)],

  'slowblink-green' => [qw(o G 3 g 3)],
  'blink-green' => [qw(o G 1 g 1)],
  'fastblink-green' => [qw(o G 0.1 g 0.1)],

  'slowblink-orange' => [qw(g O 3 o 3)],
  'blink-orange' => [qw(g O 1 o 1)],
  'fastblink-orange' => [qw(g O 0.1 o 0.1)],
  'fastblink-orange-and-power' => [qw(g O 0.1 o power-off 0.1 power-on)],

  'slowblink-both' => [qw(G O 3 g o 3)],
  'blink-both' => [qw(G O 1 g o 1)],
  'fastblink-both' => [qw(G O 0.1 g o 0.1)],
);
my %synonyms = @synonymsArr;

sub performCmd($);
sub killPidfile();
sub savePid();
sub formatSynonymsUsage();

my $EXEC = basename $0;
my $LED_CMD = "led";

my $usage = "Usage:
Turn LEDs on/off with a specified pattern using `$LED_CMD`

   $EXEC -h | --help
     print this message

   $EXEC --stop
     kills the process in pidfile $pidfile

   $EXEC SYNONYM
     run the pattern in <SYNONYM>

     SYNONYM\n" . formatSynonymsUsage() . "

   $EXEC CMD CMD CMD ....
     CMDs get performed forever in a loop
     kills the process in pidfile $pidfile and writes pid to pidfile,
       before running commands
     CMD:
       <LED_NAME>-on    turn ON led named LED_NAME
       <LED_NAME>-off   turn OFF led named LED_NAME
       G                turn ON green led
       g                turn OFF green led
       O                turn ON orange led
       o                turn OFF orange led
       <DELAY>          pause for 'DELAY' seconds {e.g. 0.1, 1.5, 30, 60.0}
     e.g.: blink lights merrily
     $EXEC o g 0.1 O 0.1 o G 0.1 g 0.1 O G 0.1
";

sub main(@){
  while(@_ > 0 and $_[0] =~ /^(-h|--help)$/){
    my $opt = shift;
    if($opt =~ /^-h|--help$/){
      print $usage;
      exit 0;
    }else{
      die "$usage\nERROR: unknown option $opt\n";
    }
  }

  if(@_ == 1 and $_[0] eq '--stop'){
    killPidfile();
    exit;
  }
  my @cmd;
  if(@_ == 1 and defined $synonyms{$_[0]}){
     @cmd = @{$synonyms{$_[0]}};
     print "$_[0] => @cmd\n";
  }else{
    @cmd = @_;
  }

  for my $cmd(@cmd){
    die $usage if $cmd !~ /^([a-zA-Z0-9_:]+-(on|off)|G|g|O|o|\d+|\d*\.\d+)$/;
  }

  die "$usage\nERROR: no CMD given\n" if @cmds == 0;

  killPidfile();
  savePid();
  while(1){
    performCmd $_ foreach @cmd;
  }
}

sub performCmd($){
  my $cmd = shift;
  if($cmd =~ /^(\d+|\d*\.\d+)$/){
    print "  (sleeping for $1 seconds)\n";
    sleep $1;
  }else{
    my ($led, $onOff);
    if($cmd =~ /^(G)$/){
      ($led, $onOff) = ("green:batt", "on");
    }elsif($cmd =~ /^(g)$/){
      ($led, $onOff) = ("green:batt", "off");
    }elsif($cmd =~ /^(O)$/){
      ($led, $onOff) = ("orange:batt", "on");
    }elsif($cmd =~ /^(o)$/){
      ($led, $onOff) = ("orange:batt", "off");
    }elsif($cmd =~ /^([a-zA-Z0-9_:]+)-(on|off)$/){
      ($led, $onOff) = ($1, $2);
    }else{
      die "UNKNOWN COMMAND: $cmd\n";
    }
    print " $led => $onOff\n";
    system "$LED_CMD $led $onOff > /dev/null";
  }
}

sub killPidfile(){
  if(-e $pidfile){
    system "kill -9 `cat $pidfile` 2>/dev/null";
  }
}
sub savePid(){
  system "echo $$ > $pidfile";
}

sub formatSynonymsUsage(){
  my $fmt = "";
  my $maxLen = max(map {length} keys %synonyms);

  for(my $i=0; $i<@synonymsArr; $i+=2){
    my $name = $synonymsArr[$i];
    my @cmd = @{$synonyms{$name}};
    $name .= ' ' x ($maxLen - length $name);
    $fmt .= "      $name   =>   @cmd\n";
  }

  return $fmt;
}

&main(@ARGV);
