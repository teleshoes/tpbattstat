#!/usr/bin/perl
use strict;
use warnings;
use File::Basename qw(basename);
use Time::HiRes qw(sleep);
use List::Util qw(max);

my $pidfile = "/tmp/led-batt-pid";

my @synonymsArr = (
  'off' => [qw(p o g 60)],
  'green' => [qw(p o G 60)],
  'orange' => [qw(p O g 60)],
  'power' => [qw(P o g 60)],
  'both' => [qw(p G O 60)],

  'slowblink-green' => [qw(o G 3 g 3)],
  'blink-green' => [qw(o G 1 g 1)],
  'fastblink-green' => [qw(o G 0.1 g 0.1)],

  'slowblink-orange' => [qw(g O 3 o 3)],
  'blink-orange' => [qw(g O 1 o 1)],
  'fastblink-orange' => [qw(g O 0.1 o 0.1)],
  'fastblink-orange-and-power' => [qw(g O 0.1 o p 0.1 P)],

  'slowblink-both' => [qw(G O 3 g o 3)],
  'blink-both' => [qw(G O 1 g o 1)],
  'fastblink-both' => [qw(G O 0.1 g o 0.1)],
);

my %synonyms = @synonymsArr;

sub parseCmdStr($);
sub performCmd($);
sub killPidfile();
sub savePid();
sub formatSynonymsUsage();

my $EXEC = basename $0;
my $LED_CMD = "led";

my $usage = "Usage:
   Turn LEDs on/off with a specified pattern using `$LED_CMD`

   $EXEC -h | --help
     print this message

   $EXEC --stop
     kills the process in pidfile $pidfile

   $EXEC [OPTS] CMD CMD CMD ....
     CMDs get performed forever in a loop (or once with --once)
     kills the process in pidfile $pidfile and writes pid to pidfile,
       before running commands

     CMD:
       <LED_NAME>-on    turn ON led named LED_NAME
       <LED_NAME>-off   turn OFF led named LED_NAME
       <DELAY>          pause for 'DELAY' seconds {e.g. 0.1, 1.5, 30, 60.0}
       G                \"green:batt-on\"   - turn ON green led
       g                \"green:batt-off\"  - turn OFF green led
       O                \"orange:batt-on\"  - turn ON orange led
       o                \"orange:batt-off\" - turn OFF orange led
       P                \"power-on\"        - turn ON power led
       p                \"power-off\"       - turn OFF power led
       <SYNONYM>        run the sequence of commands in SYNONYM

     SYNONYM:\n" . formatSynonymsUsage() . "

     OPTS
       --loop
         run this sequence forever (default)
       -o | --once
         run this sequence once, and exit
";

sub main(@){
  my $once = 0;
  while(@_ > 0 and $_[0] =~ /^(-h|--help|--loop|-o|--once)$/){
    my $opt = shift;
    if($opt =~ /^-h|--help$/){
      print $usage;
      exit 0;
    }elsif($opt =~ /^(--loop)$/){
      $once = 0;
    }elsif($opt =~ /^(-o|--once)$/){
      $once = 1;
    }else{
      die "$usage\nERROR: unknown option $opt\n";
    }
  }

  if(@_ == 1 and $_[0] eq '--stop'){
    killPidfile();
    exit;
  }

  my @cmds;
  for my $cmdStr(@_){
    @cmds = (@cmds, parseCmdStr $cmdStr);
  }

  die "$usage\nERROR: no CMD given\n" if @cmds == 0;

  killPidfile();
  savePid();
  while(1){
    performCmd $_ foreach @cmds;
    exit 0 if $once;
  }
}

sub parseCmdStr($){
  my ($cmdStr) = @_;

  my @cmds;
  if($cmdStr =~ /^([a-zA-Z0-9_:]+)-(on|off)$/){
    @cmds = ({cmd=>$1, led=>$2});
  }elsif($cmdStr =~ /^(\d+|\d*\.\d+)$/){
    @cmds = ({cmd=>"sleep", delay=>$1});
  }elsif($cmdStr =~ /^G$/){
    @cmds = ({cmd=>"on", led=>"green:batt"});
  }elsif($cmdStr =~ /^g$/){
    @cmds = ({cmd=>"off", led=>"green:batt"});
  }elsif($cmdStr =~ /^O$/){
    @cmds = ({cmd=>"on", led=>"orange:batt"});
  }elsif($cmdStr =~ /^o$/){
    @cmds = ({cmd=>"off", led=>"orange:batt"});
  }elsif($cmdStr =~ /^P$/){
    @cmds = ({cmd=>"on", led=>"power"});
  }elsif($cmdStr =~ /^p$/){
    @cmds = ({cmd=>"off", led=>"power"});
  }elsif(defined $synonyms{$cmdStr}){
    @cmds = map {parseCmdStr $_} @{$synonyms{$cmdStr}};
  }else{
    die "$usage\nERROR: unknown command $cmdStr\n";
  }

  return @cmds;
}

sub performCmd($){
  my ($cmd) = @_;
  if($$cmd{cmd} eq "on"){
    system "$LED_CMD $$cmd{led} on > /dev/null";
  }elsif($$cmd{cmd} eq "off"){
    system "$LED_CMD $$cmd{led} off > /dev/null";
  }elsif($$cmd{cmd} eq "sleep"){
    sleep $$cmd{delay};
  }else{
    die "ERROR: unknown cmd\n";
  }
}

sub killPidfile(){
  if(-e $pidfile){
    system "kill -9 `cat $pidfile` 2>/dev/null";
  }
}
sub savePid(){
  system "echo $$ > $pidfile";
}

sub formatSynonymsUsage(){
  my $fmt = "";
  my $maxLen = max(map {length} keys %synonyms);

  for(my $i=0; $i<@synonymsArr; $i+=2){
    my $name = $synonymsArr[$i];
    my @cmd = @{$synonyms{$name}};
    $name .= ' ' x ($maxLen - length $name);
    $fmt .= "      $name   =>   @cmd\n";
  }

  return $fmt;
}

&main(@ARGV);
